from typing import TypeVar, Generic, Any, overload, List, Tuple, Optional

from .expression import BinaryExpression, UnaryExpression
from .field import Field
from .model import Model

T = TypeVar('T')
T0 = TypeVar('T0')
T1 = TypeVar('T1')
T2 = TypeVar('T2')
T3 = TypeVar('T3')
T4 = TypeVar('T4')
T5 = TypeVar('T5')
T6 = TypeVar('T6')
M = TypeVar('M', bound=Model)
Q = TypeVar('Q', bound='Query')


class Query(Generic[T]):
    def filter(self: Q, *expressions: BinaryExpression, **expression_dict: Any) -> Q: ...
    @overload
    def map(self, entity: M) -> Query[M]: ...
    @overload
    def map(self, entity0: Field[T0]) -> Query[T0]: ...
    @overload
    def map(self, entity0: Field[T0], entity1: Field[T1]) -> Query[Tuple[T0, T1]]: ...
    @overload
    def map(self, entity0: Field[T0], entity1: Field[T1], entity: Field[T2]) -> Query[Tuple[T0, T1, T2]]: ...
    @overload
    def map(self, entity0: Field[T0], entity1: Field[T1], entity2: Field[T2], entity3: Field[T3]) -> Query[Tuple[T0, T1, T2, T3]]: ...
    @overload
    def map(self, *entities: Any): ...
    def all(self) -> List[T]: ...
    def first(self) -> Optional[T]: ...
    def limit(self: Q, limit: int) -> Q: ...
    def offset(self: Q, offset: int) -> Q: ...
    def order_by(self: Q, *criterion: UnaryExpression) -> Q: ...
    def group_by(self: Q, *criterion: Field) -> Q: ...
    def having(self: Q, *expressions: BinaryExpression, **expression_dict: Any) -> Q: ...
    def on(self: Q, *expressions: BinaryExpression, **expression_dict: Any) -> Q: ...
    def for_update(self: Q) -> Q: ...
    def count(self) -> int: ...
    def count_and_all(self) -> Tuple[int, List[T]]: ...
    def update(self: Q, **values: Any) -> Optional[T]: ...
    def delete(self: Q) -> Optional[T]: ...
